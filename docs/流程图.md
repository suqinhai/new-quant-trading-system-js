# 交易系统链路说明（白话 + 关键方法名）

> **只记住一句话：**  
> **行情广播 → 策略判断 → 发单信号 → 风控拦截 / 放行 → 执行器下单（或影子模拟）**

---

## 一、共享行情模式：从交易所推送到下单

### 1. 行情服务启动并连接交易所

- `MarketDataService.start()`  
  → `MarketDataEngine.start()`
- 交易所 **WS / REST** 行情推送进入 `MarketDataEngine`
- 代码位置：  
  `src/services/MarketDataService.js`

---

### 2. 行情服务把数据广播到 Redis

- `MarketDataService._publishMarketData()`
- 向 Redis 频道 `market_data` 发布：
  - `kline`
  - `ticker`
  - …
- 代码位置：  
  `src/services/MarketDataService.js`

---

### 3. 策略容器订阅 Redis 行情

- `MarketDataSubscriber.connect()`
- 收到 Redis 消息后：
  - `_handleMessage()`
  - `emit('kline' | 'ticker')`
- 代码位置：  
  `src/services/MarketDataSubscriber.js`

---

### 4. main.js 把行情交给策略

- `TradingSystemRunner._bindSharedMarketDataEvents()`
- 收到 `kline`：
  - 调用 `strategy.onCandle()`
- 代码位置：  
  `src/main.js`

---

### 5. 策略真正计算交易信号

- `BaseStrategy.onCandle()`  
  → `strategy.onTick(candle, history)`
- **你自己的策略逻辑全部写在 `onTick()`**
- 代码位置：
  - `src/strategies/BaseStrategy.js`
  - 各具体策略文件

---

### 6. 策略“真发单”必须调用的方法

- ✅ **真正会走下单链路**
  - `buy()`
  - `buyPercent()`
  - `closePosition()`

- 调用链路：
  - `engineAdapter.buy / sell`
  - `strategy.emit('signal')`

- ⚠️ 注意：
  - `setBuySignal()` / `setSellSignal()`  
    **只记日志，不会下单**

- 代码位置：
  - `src/strategies/BaseStrategy.js`
  - `src/main.js`

---

### 7. 系统收信号 → 风控 → 下单

- `TradingSystemRunner._bindStrategyEvents()` 收到 `signal`
- 执行流程：
  - `_handleSignal()`
  - `riskManager.checkOrder()`
  - 通过 → `executor.executeOrder()`

- 模式区分：
  - **影子模式**：`_executeDryRunOrder()`
  - **实盘模式**：`exchange.createOrder()`

- 代码位置：
  - `src/main.js`
  - `src/risk/manager.js`
  - `src/executor/orderExecutor.js`

---

## 二、系统级「紧急熔断 / 强平」

- 风控触发：
  - `AdvancedRiskManager` 内部触发 `emergencyClose`
- 主链路：
  - `main.js` → `_handleEmergencyClose()`
  - `executor.emergencyCloseAll()`
- 代码位置：
  - `src/risk/manager.js`
  - `src/main.js`
  - `src/executor/orderExecutor.js`

---

## 三、WeightedCombo 内部信号合成 + 熔断

### 1. 每根 K 线入口

- `WeightedComboStrategy.onTick()`
- 调用：
  - `_collectSignals()`
  - 依次执行 `subStrategy.onTick()`
- 代码位置：  
  `src/strategies/WeightedComboStrategy.js`

---

### 2. 子策略打分

- 指标 → `SignalConverter`
- 输出 **0 ~ 1** 分
- `SignalWeightingSystem.recordSignal()`
- 代码位置：
  - `src/strategies/WeightedComboStrategy.js`
  - `src/strategies/SignalWeightingSystem.js`

---

### 3. 合成总分

- `SignalWeightingSystem.calculateScore()`
- 输出：
  - `action = buy | sell | hold`
- 代码位置：  
  `src/strategies/SignalWeightingSystem.js`

---

### 4. 触发交易

- `WeightedComboStrategy._executeTrading()`
- 调用：
  - `buyPercent()`
  - `closePosition()`
- 随后进入：
  - **一 · 6 → 7 的统一下单链路**
- 代码位置：  
  `src/strategies/WeightedComboStrategy.js`

---

### 5. 子策略熔断（非全系统停机）

- 触发点：
  - `WeightedComboStrategy._executeExit()`
- 表现更新：
  - `SignalWeightingSystem.updatePerformance()`
- 熔断判断：
  - `_checkCircuitBreaker()`
  - `_triggerCircuitBreak()`
- 熔断效果：
  - 子策略被强制记为 **0.5（中性分）**
  - 冷却期后自动恢复
- 代码位置：  
  `src/strategies/SignalWeightingSystem.js`

---

## 备注

可按具体策略（如 `SMA` / `WeightedCombo`）  
生成 **「逐行函数 → 日志 → 行为」对照清单**，直接对日志排错。
